options{  static = true;}PARSER_BEGIN(Glat)package glat;import glat.program.*;import glat.program.instructions.*;import glat.program.instructions.expressions.*;import glat.program.instructions.expressions.terminals.*;import glat.program.instructions.expressions.terminals.Number;import java.io.*;public class Glat{  private static Program p;  public Glat()  {}  public Program parse(String args []) throws ParseException, FileNotFoundException  {    Glat parser;    p = new Program();    System.out.println("Welcome");    if (args.length > 0)    {      System.out.println("File");      FileInputStream is = new FileInputStream(new File(args [0]));      parser = new Glat(new BufferedInputStream(is));    }    else    {      System.out.println("Hand");      parser = new Glat(System.in);    }    System.out.println("Parser");    parser.Input();    System.out.println("End\n\n\n");    return p;  }}PARSER_END(Glat)SKIP :{  " "| "\t"| "\n"| "\r"}TOKEN :{  < LPAR : "(" >| < RPAR : ")" >| < LBRA : "{" >| < RBRA : "}" >| < DOTC : ";" >}TOKEN :{ /* Operators */  < ASIG : ":=" >| < SUM : "+" >| < MIN : "-" >| < DIV : "/" >| < AST : "*" >| < LT : "<" >| < GT : ">" >| < LET : "<=" >| < GET : ">=" >| < EQ : "==" >| < NEQ : "!=" >}TOKEN : /* Key Words */{  < VAR : "var" >| < START : "start" >| < TRAN : "trans" >| < TO : "->" >| < ASSU : "assume" >| < ASSE : "assert" >| < THRE : "async" >| < JOIN : "join" >| < VOID : "void" >| < LOCK : "lock" >| < UNLOCK : "unlock" >| < RETU : "return" >| < CALL : "sync" >}TOKEN : /* TERMS */{  < ID :    < CHAR >    (      < CHAR >    | < DIGIT >    )* >| < NUM :    (< MIN >)? (< DIGIT >)+    (      < DOT > (< DIGIT >)+    )? >| < #DIGIT : [ "0"-"9" ] >| < #CHAR : [ "a"-"z", "A"-"Z" ] >| < #DOT : "." >| < COMA : "," >}/* Program */void Input() : //DONE: :D{  Declaration v;  Method m;}{  (    v = Decl("global") < DOTC >    {      p.addDeclaration(v);    }  )*  (    m = Func()    {      p.addMethod(m);    }  )+  < EOF >  {    p.checkCalls();  }}//-------------------------------------------------/* Variables */Declaration Decl(String env) : //DONE: :D{  Declaration v;  String s;  Token t;}{  < VAR > s = V_type() t = < ID >  {    v = new Declaration(s, t.image,env);    return v;  }}/* Methods */Method Func() : //DONE: :D{  Method m;  String s;  Token t;  Declaration v;  String label;}{  s = Type() t = < ID >  {    m = new Method(s, t.image);    label = m.getLabel();  }  < LPAR >  (    v = Decl(label)    {      m.addParameter(v);    }    (      < COMA > v = Decl(label)      {        m.addParameter(v);      }    )*  )?  < RPAR > < LBRA >  (    v = Decl(label) < DOTC >    {      m.addDeclaration(v);    }  )*  Cfg(m)  < RBRA >  {    return m;  }}/* CFG */void Cfg(Method m) : //DONE: :D{  Token t;  Transition tr;  int j = 0;}{  < START > t = < ID >  {    m.addEntryPoint(t.image);  }< DOTC >  (    tr = Tran(m, j++)    {      m.addTransition(tr);    }  )+}Transition Tran(Method m, int j) : // DONE: :D{  Transition tr;  Token t1, t2;  Instruction i;}{  < TRAN > t1 = < ID > < TO > t2 = < ID >  {    tr = new Transition(m, j, t1.image, t2.image);  }  < LBRA >  (    i = Inst(m, tr)    {      tr.addInstruction(i);    }  )*  < RBRA >  {    return tr;  }}Instruction Inst(Method m, Transition tr) :{  Instruction i;  Token t;}{  (    i = Asig(m, tr)  | i = Lock(m, tr)  | i = Return(m, tr)  | i = Join(m, tr)  | i = Call(m, tr)  | i = Assume(m, tr)  | i = Assert(m, tr)  )  t = < DOTC >  {    i.setPosition(t.beginLine);    return i;  }}Instruction Call(Method m, Transition tr) :{	Token t,n;	Call c;	Variable v;}{  (    t = < THRE >  | t = < CALL >  )  n = < ID >{	c = new Call(n.image,t.image);}   < LPAR >  (    v = Var(m,tr)    { 	c.addParameter(v);         }    (< COMA > v = Var(m,tr)    { 	c.addParameter(v);         })*  )?  < RPAR >  {    return c;  }}Instruction Lock(Method m, Transition tr) :{	Token t;	Variable v;}{  (    t=< LOCK >  | t=< UNLOCK >  )  v = Var(m,tr)  {    return new Lock(t.image,v);  }}Instruction Return(Method m, Transition tr) :{  Terminal t;}{  < RETU >  (    t = Term(m, tr)    {      return new Return(t);    }  )?  {    return new Return();  }}Instruction Join(Method m, Transition tr) :{	Variable v;}{  < JOIN > v = Var(m,tr)  {    return new Join(v);  }}Instruction Assert(Method m, Transition tr) : // DONE: :D{  String o;  Terminal t1, t2;}{  < ASSE > < LPAR > t1 = Term(m, tr) o = Op_c() t2 = Term(m, tr) < RPAR >  {    return new Assert(o,t1,t2);  }}Instruction Assume(Method m, Transition tr) : // DONE: :D{  String o;  Terminal t1, t2;}{  < ASSU > < LPAR > t1 = Term(m, tr) o = Op_c() t2 = Term(m, tr) < RPAR >  {    return new Assume(o,t1,t2);  }}Instruction Asig(Method m, Transition tr) :{  Variable v;  Expression exp;  Instruction i;}{  v = Var(m, tr) < ASIG >  (    exp = Expr(m, tr)    {      return new Asignation(v, exp);    }  | i = Call(m, tr)    {      ((Call) i).setReturn(v);      return i;    }  )}Expression Expr(Method m, Transition tr) :{  String o = "-1";  Terminal t1, t2=new TopValue();  Instruction i;  Token t;}{  (    t1 = Term(m, tr)    (      o = Op() t2 = Term(m, tr)    )?    {      if (o.equals("-1")) return new Expression(t1);      else return new Expression(o, t1, t2);    }  /*| i = Call(m, tr)    {      return new Expression(i);    }*/  )}/*	Terminal Tokens...*/Terminal Term(Method m, Transition tr) :{  Token t;  Terminal ter;}{  (    ter = Var(m,tr)    {      return ter;    }  | ter = Numb()    {      return ter;    }  | t = < AST >    {      return new TopValue(t);    }  )}Variable Var(Method m, Transition tr) :{	Token t;}{t = < ID >    {      Declaration d = m.getVariable(t.image);      if (d == null)      {        d = p.getVariable(t.image);        if (d == null) throw new Error("Missing Declaration for " + t.image);      }      return new Variable(d, t);    }}String Op_c() : // DONE: :D{  Token t;}{  (    t = < LT >  | t = < GT >  | t = < LET >  | t = < GET >  | t = < EQ >  | t = < NEQ >  )  {    return t.image;  }}String Op() : // DONE: :D{  Token t;  String s;}{  (    (      t = < SUM >    | t = < MIN >    | t = < DIV >    | t = < AST >    )    {      return t.image;    }  | s = Op_c()    {      return s;    }  )}Number Numb() : // DONE: :D{  Token t;}{  t = < NUM >  {    return new Number(t.image);  }}String Type() : // DONE: :D{  Token t;  String s;}{  (    t = < VOID >    {      return t.image;    }  | s = V_type()    {      return s;    }  )}String V_type() : // DONE: :D{  Token t;  String s;}{  (    t = < LOCK >    {      return t.image;    }  | t = < THRE >    {      return t.image;    }  | s = P_type()    {      return s;    }  )}String P_type() : // DONE: :D{  Token t;}{  t = < ID >  {    return t.image;  }}