options{  static = true;}PARSER_BEGIN(Glat)package glat.parser;import glat.program.*;import glat.program.instructions.*;import glat.program.instructions.expressions.*;import glat.program.instructions.expressions.terminals.*;import glat.program.instructions.expressions.terminals.Number;import java.io.*;public class Glat{  private static GlatProgram p;  private static GlatMethod currMethod;  public Glat(){}  public GlatProgram parse(String args []) throws ParseException, FileNotFoundException{    Glat parser;    p = new GlatProgram();    if (args.length > 0){      FileInputStream is = new FileInputStream(new File(args [0]));      parser = new Glat(new BufferedInputStream(is));    }    else{      parser = new Glat(System.in);    }    parser.Input();    System.out.println("End Parser\n\n\n");    return p;  }  private static boolean addDeclaration(Variable v){	Declaration d = currMethod.getVariable(v.getValue());      if (d == null)      {        d = p.getGlobalVariable(v.getValue());        if (d == null) return false;//throw new Error("Missing Declaration for " + v.getValue());      }      v.setDeclaration(d);      return true;  }}PARSER_END(Glat)SKIP :{  " "| "\t"| "\n"| "\r"}TOKEN :{  < LPAR : "(" >| < RPAR : ")" >| < LBRA : "{" >| < RBRA : "}" >| < DOTC : ";" >}TOKEN :{ /* Operators */  < ASIG : ":=" >| < SUM  : "+"  >| < MIN  : "-"  >| < DIV  : "/"  >| < AST  : "*"  >| < LT   : "<"  >| < GT   : ">"  >| < LET  : "<=" >| < GET  : ">=" >| < EQ   : "==" >| < NEQ  : "!=" >}TOKEN : /* Key Words */{  < VAR    : "var"    >| < GLOBAL : "global" >| < INIT   : "init"   >| < MAIN   : "main"   >| < START  : "start"  >| < TRAN   : "trans"  >| < TO     : "->"     >| < ASSU   : "assume" >| < ASSE   : "assert" >| < THRE   : "thread" >| < JOIN   : "join"   >| < VOID   : "void"   >| < LOCK   : "lock"   >| < UNLOCK : "unlock" >| < RETU   : "return" >| < CALL   : "call"   >}TOKEN : /* TERMS */{  < ID :    < CHAR >    (      < CHAR >    | < DIGIT >    )* >| < NUM :    (< MIN >)? (< DIGIT >)+    (      < DOT > (< DIGIT >)+    )? >| < #DIGIT : [ "0"-"9" ] >| < #CHAR : [ "a"-"z", "A"-"Z" ] >| < #DOT : "." >| < COMA : "," >}/* Program */void Input() :{	Declaration dl;	GlatInstruction i;	ThreadLaunch th_l;	GlatMethod m;	MainMethod main = new MainMethod();}{ < GLOBAL > < LBRA >	  (	    dl = Decl("global") < DOTC >	    {	      p.addDeclaration(dl);	    }	  )*  < RBRA >  < INIT > < LBRA >	  (	    	i = InitDecl()	    {	     	p.addInitInstr(i); 	    }	  ) *  < RBRA >  < MAIN > < LBRA >	  (	    dl = Decl("main") < DOTC >	    {	      main.addDeclaration(dl);	    }	  )*	  (	    < LBRA >		  (		    	i = InitDecl()		    {		     	main.addInitInstr(i); 		    }		  ) *	  < RBRA >	)?	  (	    th_l = Threads()	    {	     main.addThread(th_l); 	    }	  ) *  < RBRA >  (    m = Func()    {      p.addMethod(m);    }  )*  < EOF >  {    p.checkProgram();  } }//-------------------------------------------------/* Threads */ThreadLaunch Threads() :{  Token t,t2= null;  String s;  GlatInstruction cl;  Number nu=null;}{	< THRE > t = < ID >	(	  nu = Numb()	  | t2 = < AST >	) cl = Call()	{	  	if(t2 != null)			return new ThreadLaunch(t.image,nu,(Call)cl);		else			return new ThreadLaunch(t.image,(Call)cl);	}}//-------------------------------------------------/* Variables */Declaration Decl(String env) : //DONE: :D{  Declaration v;  String s;  Token t;}{  < VAR > s = V_type() t = < ID >  {    v = new Declaration(s, t.image,env);    return v;  }}GlatInstruction InitDecl() :{GlatInstruction i;}{  	(  	  	  i = Assume()	| i = Asig()	)	{		return i;	}	}/* Methods */GlatMethod Func() : //DONE: :D{  GlatMethod m;  GlatCFG cfg;  String s;  Token t;  Declaration v;  String label;}{  s = Type() t = < ID >  {    m = new GlatMethod(s, t.image);    currMethod = m;    label = m.getLabel();  }  < LPAR >  (    v = Decl(label)    {      m.addParameter(v);    }    (      < COMA > v = Decl(label)      {        m.addParameter(v);      }    )*  )?  < RPAR > < LBRA >  (    v = Decl(label) < DOTC >    {      m.addDeclaration(v);    }  )*  cfg = Cfg(m)  < RBRA >  {    m.addCFG(cfg);    return m;  }}/* CFG */GlatCFG Cfg(GlatMethod m) : //DONE: :D{  Token t;  GlatTransition tr;  GlatCFG cfg;  int j = 0;}{  < START > t = < ID >  {    cfg = new GlatCFG(t.image);  }< DOTC >  (    tr = Tran(cfg, m, j++)    {      cfg.addTransition(tr);    }  )+  {	return cfg;  }}GlatTransition Tran(GlatCFG cfg, GlatMethod m, int j) : // DONE: :D{  GlatTransition tr;  Token t1, t2;  GlatInstruction i;  GlatNode n1,n2;}{  < TRAN > t1 = < ID > < TO > t2 = < ID >  { 	n1 = (GlatNode) cfg.getNode(t1.image); 	n2 = (GlatNode) cfg.getNode(t2.image);       tr = new GlatTransition(m, j, n1, n2);  }  < LBRA >  (    i = Inst(m, tr)    {      tr.addInstruction(i);    }  )*  < RBRA >  {    return tr;  }}GlatInstruction Inst(GlatMethod m, GlatTransition tr) :{  GlatInstruction i;  Token t;}{  (    i = Asig()  | i = Lock()  | i = Return()  | i = Join()  | i = Call()  | i = Assume()  | i = Assert()  )  t = < DOTC >  {    i.setUbication(m,tr);    i.setPosition(t.beginLine,t.beginColumn);    return i;  }}GlatInstruction Call() :{	Token t,n;	Call c;	Variable v;	String s = "async";}{  	  t = < CALL >  	  {		s = t.image;  	  }  n = < ID >{		c = new Call(n.image,s);}   < LPAR >  (    v = Var()    { 	c.addParameter(v);         }    (< COMA > v = Var()    { 	c.addParameter(v);         })*  )?  < RPAR >  {    return c;  }}GlatInstruction Lock() :{	Token t;	Variable v;}{  (    t=< LOCK >  | t=< UNLOCK >  )  v = Var()  {    return new Lock(t.image,v);  }}GlatInstruction Return() :{  Terminal t;}{  < RETU >  (    t = Term()    {      return new Return(t);    }  )?  {    return new Return();  }}GlatInstruction Join() :{	Variable v;}{  < JOIN > v = Var()  {    return new Join(v);  }}GlatInstruction Assert() : // DONE: :D{  String o;  Terminal t1, t2;}{  < ASSE > < LPAR > t1 = Term() o = Op_c() t2 = Term() < RPAR >  {    return new Assert(o,t1,t2);  }}GlatInstruction Assume() : // DONE: :D{  String o;  Terminal t1, t2;}{  < ASSU > < LPAR > t1 = Term() o = Op_c() t2 = Term() < RPAR >  {    return new Assume(o,t1,t2);  }}GlatInstruction Asig() :{  Variable v;  Expression exp;  GlatInstruction i;}{  v = Var() < ASIG >  (    exp = Expr()    {      return new Asignation(v, exp);    }  | i = Call()    {      ((Call) i).setReturn(v);      return i;    }  )}Expression Expr() :{  String o = "-1";  Terminal t1, t2=new TopValue();  GlatInstruction i;  Token t;}{  (    t1 = Term()    (      o = Op() t2 = Term()    )?    {      if (o.equals("-1")) return new Expression(t1);      else return new Expression(o, t1, t2);    }  /*| i = Call(m, tr)    {      return new Expression(i);    }*/  )}/*	Terminal Tokens...*/Terminal Term() :{  Token t;  Terminal ter;}{  (    ter = Var()    {      return ter;    }  | ter = Numb()    {      return ter;    }  | t = < AST >    {      return new TopValue(t);    }  )}Variable Var() :{	Token t;	Variable v;}{t = < ID >    {      v = new Variable(t);      addDeclaration(v);      return v;    }}String Op_c() : // DONE: :D{  Token t;}{  (    t = < LT >  | t = < GT >  | t = < LET >  | t = < GET >  | t = < EQ >  | t = < NEQ >  )  {    return t.image;  }}String Op() : // DONE: :D{  Token t;  String s;}{  (    (      t = < SUM >    | t = < MIN >    | t = < DIV >    | t = < AST >    )    {      return t.image;    }  | s = Op_c()    {      return s;    }  )}Number Numb() : // DONE: :D{  Token t;}{  t = < NUM >  {    return new Number(t.image);  }}String Type() : // DONE: :D{  Token t;  String s;}{  (    t = < VOID >    {      return t.image;    }  | s = V_type()    {      return s;    }  )}String V_type() : // DONE: :D{  Token t;  String s;}{  (    t = < LOCK >    {      return t.image;    }  | t = < THRE >    {      return t.image;    }  | s = P_type()    {      return s;    }  )}String P_type() : // DONE: :D{  Token t;}{  t = < ID >  {    return t.image;  }}