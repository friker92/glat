options{  static = true;}PARSER_BEGIN(Glat)package glat.parser;import glat.program.*;import glat.program.instructions.*;import glat.program.instructions.expressions.*;import glat.program.instructions.expressions.terminals.*;import glat.program.instructions.expressions.terminals.values.*;import java.io.*;public class Glat{  private static GlatProgram p;  private static GlatMethod currMethod;  public Glat(){}  public GlatProgram parse(String args []) throws ParseException, FileNotFoundException{    Glat parser;    p = new GlatProgram();    if (args.length > 0){      FileInputStream is = new FileInputStream(new File(args [0]));      parser = new Glat(new BufferedInputStream(is));    }    else{      parser = new Glat(System.in);    }    parser.Input();    System.out.println("End Parser\n\n\n");    return p;  }  public static Variable getVariable(Token t)  {		Variable v = currMethod.getVariable(t.image);		if (v == null)		{		  v = p.getGlobalVariable(t.image);		  if(v == null)		  	throw new Error("Variable: "+t.image+ "does not exists on this scope");		}		return v;	  }}PARSER_END(Glat)SKIP :{  " "| "\t"| "\n"| "\r"}/* COMMENTS */<AFTER_EGEN> SKIP : {<~[]> : DEFAULT}SKIP :{  < "//" (~["\r", "\n"])* >| < "/*" > : ML_COMMENT_STATE}<ML_COMMENT_STATE> SKIP :{  < "*/" > : DEFAULT| < ~[] >   }   TOKEN :{  < LPAR : "(" >| < RPAR : ")" >| < LBRA : "{" >| < RBRA : "}" >| < DOTC : ";" >| < COMA : "," >}TOKEN :{ /* Operators */  < OPR : "$op" >| < ASSIG : ":=" >| < SUM  : "+"  >| < MIN  : "-"  >| < DIV  : "/"  >| < AST  : "*"  >| < LT   : "<"  >| < GT   : ">"  >| < LET  : "<=" >| < GET  : ">=" >| < EQ   : "==" >| < NEQ  : "!=" >}TOKEN : /* Key Words */{  < VAR    : "var"    >| < GLOBAL : "global" >| < INIT   : "init"   >| < MAIN   : "main"   >| < START  : "start"  >| < TRAN   : "trans"  >| < TO     : "->"     >| < ASSU   : "assume" >| < ASSE   : "assert" >| < THRE   : "async" >| < JOIN   : "join"   >| < VOID   : "void"   >| < LOCK   : "lock"   >| < UNLOCK : "unlock" >| < RETU   : "return" >| < CALL   : "sync"   >}TOKEN : /* IDs */{  < ID : < LETTER > (< PART_LETTER >)* >| < #LETTER : ["A"-"Z","_","a"-"z"] >| < #PART_LETTER : (< LETTER > | ["0"-"9"]) >}/* LITERALS */<DEFAULT> TOKEN : {<INTEGER_LITERAL: <DECIMAL_LITERAL> (["l","L"])? | <HEX_LITERAL> (["l","L"])? | <OCTAL_LITERAL> (["l","L"])?>| <#DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])*>| <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+>| <#OCTAL_LITERAL: "0" (["0"-"7"])*>| <FLOAT_LITERAL: <DECIMAL_FLOATING_POINT_LITERAL> | <HEXADECIMAL_FLOATING_POINT_LITERAL>>| <#DECIMAL_FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<DECIMAL_EXPONENT>)? (["f","F","d","D"])? | "." (["0"-"9"])+ (<DECIMAL_EXPONENT>)? (["f","F","d","D"])? | (["0"-"9"])+ <DECIMAL_EXPONENT> (["f","F","d","D"])? | (["0"-"9"])+ (<DECIMAL_EXPONENT>)? ["f","F","d","D"]>| <#DECIMAL_EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+>| <#HEXADECIMAL_FLOATING_POINT_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ (".")? <HEXADECIMAL_EXPONENT> (["f","F","d","D"])? | "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])* "." (["0"-"9","a"-"f","A"-"F"])+ <HEXADECIMAL_EXPONENT> (["f","F","d","D"])?>| <#HEXADECIMAL_EXPONENT: ["p","P"] (["+","-"])? (["0"-"9"])+>| <#CHAR1: (~["\'","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])? | ["0"-"3"] ["0"-"7"] ["0"-"7"])) >| <#CHAR2: (~["\"","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])? | ["0"-"3"] ["0"-"7"] ["0"-"7"])) >| <STRING_LITERAL: ("\"" ( < CHAR1 > )* "\"" | "\'" ( < CHAR2 > )* "\'")>| < BOOL_LITERAL: ("true" | "false") >}   /* Program */void Input() :{	Variable v;	GlatInstruction i;	ThreadLaunch th_l;	GlatMethod m;	MainMethod main = new MainMethod();}{ < GLOBAL > < LBRA >	  (	    v = Decl() < DOTC >	    {	      p.addVar(v);	    }	  )*  < RBRA >  < INIT > < LBRA >	  (	    	i = InitDecl()	    {	     	p.addInitInstr(i); 	    }	  ) *  < RBRA >/*  < MAIN > < LBRA >	  (	    dl = Decl("main") < DOTC >	    {	      main.addDeclaration(dl);	    }	  )*	  (	    < LBRA >		  (		    	i = InitDecl()		    {		     	main.addInitInstr(i); 		    }		  ) *	  < RBRA >	)?	  (	    th_l = Threads() < DOTC >	    {	     main.addThread(th_l); 	    }	  ) *  < RBRA >*/  (    m = Func()    {      p.addMethod(m);    }  )*  < EOF >  {    //p.addMainMethod(main);    p.checkProgram();  } }//-------------------------------------------------/* Threads */ThreadLaunch Threads() :{  Token t,t2= null;  String s;  GlatInstruction cl;  Values nu=null;}{	< THRE > t = < ID >	(	  t2 = < INTEGER_LITERAL >	  | t2 = < AST >	) cl = Call()	{	  	if(t2 == null)			return new ThreadLaunch(t.image,t2,(Call)cl);		else			return new ThreadLaunch(t.image,(Call)cl);	}}//-------------------------------------------------/* Variables */Variable Decl() : {  String s;  Token t;}{  < VAR > s = V_type() t = < ID >  {    return new Variable(s, t.image);  }}GlatInstruction InitDecl() :{	GlatInstruction i;}{  	(  	  	  i = Assume()	| i = Assig()	)	{		return i;	}	}/* Methods */GlatMethod Func() : //DONE: :D{  GlatMethod m;  GlatCFG cfg;  String s;  Token t;  Variable v;  String label;}{  s = Type() t = < ID >  {    m = new GlatMethod(s, t.image);    currMethod = m;    label = m.getLabel();  }  < LPAR >  (    v = Decl()    {      m.addParameter(v);    }    (      < COMA > v = Decl()      {        m.addParameter(v);      }    )*  )?  < RPAR > < LBRA >  (    v = Decl() < DOTC >    {      m.addVar(v);    }  )*  cfg = Cfg(m)  < RBRA >  {    m.addCFG(cfg);    return m;  }}/* CFG */GlatCFG Cfg(GlatMethod m) : //DONE: :D{  Token t;  GlatTransition tr;  GlatCFG cfg;  int j = 0;}{  < START > t = < ID >  {    cfg = new GlatCFG(t.image);  }< DOTC >  (    tr = Tran(cfg, m, j++)    {      cfg.addTransition(tr);    }  )+  {	return cfg;  }}GlatTransition Tran(GlatCFG cfg, GlatMethod m, int j) : // DONE: :D{  GlatTransition tr;  Token t1, t2;  GlatInstruction i;  GlatNode n1,n2;}{  < TRAN > t1 = < ID > < TO > t2 = < ID >  { 	n1 = (GlatNode) cfg.getNode(t1.image); 	n2 = (GlatNode) cfg.getNode(t2.image);       tr = new GlatTransition(m, j, n1, n2);  }  < LBRA >  (    i = Inst(m, tr)    {      tr.addInstruction(i);    }  )*  < RBRA >  {    return tr;  }}GlatInstruction Inst(GlatMethod m, GlatTransition tr) :{  GlatInstruction i;  Token t;}{  (    i = Assig()  | i = Lock()  | i = Return()  | i = Join()  | i = Call()  | i = Assume()  | i = Assert()  )  t = < DOTC >  {    i.setUbication(m,tr);    i.setPosition(t.beginLine,t.beginColumn);    return i;  }}GlatInstruction Call() :{	Token t,n;	Call c;	Variable v;	String s;}{	(	  t = < THRE > | t = < CALL >)  	  {		s = t.image;  	  }  n = < ID >{		c = new Call(n.image,s);}   < LPAR >  (    v = Var()    { 	c.addParameter(v);         }    (< COMA > v = Var()    { 	c.addParameter(v);         })*  )?  < RPAR >  {    return c;  }}GlatInstruction Lock() :{	Token t;	Variable v;}{  (    t=< LOCK >  | t=< UNLOCK >  )  v = Var()  {    return new Lock(t.image,v);  }}GlatInstruction Return() :{  Terminal t;}{  < RETU >  (    t = Term()    {      return new Return(t);    }  )?  {    return new Return();  }}GlatInstruction Join() :{	Variable v;}{  < JOIN > v = Var()  {    return new Join(v);  }}GlatInstruction Assert() : // DONE: :D{  String o;  Terminal t1, t2;  Expression e;}{  < ASSE > < LPAR > e = ExprBool() < RPAR >  {    return new Assert(e);  }}GlatInstruction Assume() : // DONE: :D{  String o;  Terminal t1, t2;  Expression e;}{  < ASSU > < LPAR > e = ExprBool() < RPAR >  {    return new Assume(e);  }}GlatInstruction Assig() :{  Variable v;  Expression exp;  GlatInstruction i;}{  v = Var() < ASSIG >  (    exp = Expr()    {      return new Assignment(v, exp);    }  | i = Call()    {      ((Call) i).setReturn(v);      return i;    }  )}Expression Expr() :{  String o = null;  Terminal t1, t2=null;  GlatInstruction i;  Token t;  Expression e;}{  (    t1 = Term()    (      o = Op() t2 = Term()    )?    {      e = new Expression();      e.addOperand(t1);      if (o!=null)      {        e.setOperator(o);        e.addOperand(t2);      }    }| e = PrefixExpr()){  return e;}  }Expression ExprBool() :{  Terminal t1,t2;  String o;	Expression e;}{	(t1 = Term() o = Op_c() t2 = Term(){	e = new Expression();	e.addOperator(o);	e.addOperand(t1);	e.addOperand(t2);}| t1 = < BOOL_LITERAL >{	e = new Expression();	e.addOperand(new BoolValue(t1.image));}| e = PrefixExpr() 	)	{	  return e;	}}Expression PrefixExpr() :{	Expression e = new Expression();	Terminal ter;	Token op;}{	< OPR > < LPAR >	op = < STRING_LITERAL > /* Operator*/	{		e.setOperator(op.image);	}	(	  < COMA > ter = Term()	  {		e.addOperand(ter);	  }	)+	< RPAR >	{		return e;	}}/*	Terminal Tokens...*/Terminal Term() :{  Token t;  Terminal ter;}{  (    ter = Var()    {      return ter;    }  | ter = Value()    {      return ter;    }  | t = < AST >    {      return new NonDeterministicValue(t);    }  )}Variable Var() :{	Token t;	Variable v;}{t = < ID >    {      return getVariable(t);    }}String Op_c() : // DONE: :D{  Token t;}{  (    t = < LT >  | t = < GT >  | t = < LET >  | t = < GET >  | t = < EQ >  | t = < NEQ >  )  {    return t.image;  }}String Op() : // DONE: :D{  Token t;  String s;}{  (    (      t = < SUM >    | t = < MIN >    | t = < DIV >    | t = < AST >    )    {      return t.image;    }  | s = Op_c()    {      return s;    }  )}Values Value() : // DONE: :D{  Token t;}{  (    t = < INTEGER_LITERAL >  	{    	return new IntNumber(t.image);  	} | t= < FLOAT_LITERAL >  	{    	return new FloatNumber(t.image);  	} | t = < STRING_LITERAL > 	{    	return new StringValue(t.image);  	} | t = < BOOL_LITERAL > 	{    	return new BoolValue(t.image);  	}	) }String Type() : // DONE: :D{  Token t;  String s;}{  (    t = < VOID >    {      return t.image;    }  | s = V_type()    {      return s;    }  )}String V_type() : // DONE: :D{  Token t;  String s;}{  (    t = < LOCK >    {      return t.image;    }  | t = < THRE >    {      return t.image;    }  | s = P_type()    {      return s;    }  )}String P_type() : // DONE: :D{  Token t;}{  t = < ID >  {    return t.image;  }}