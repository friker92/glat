options{  static = true;}PARSER_BEGIN(Glat)package glat.parser;import glat.program.*;import glat.program.instructions.*;import glat.program.instructions.expressions.*;import glat.program.instructions.expressions.terminals.*;import glat.program.instructions.expressions.terminals.values.*;import java.io.*;public class Glat{  private static GlatProgram p;  private static GlatMethod currMethod;  public Glat()  {}  public GlatProgram parse(String args []) throws ParseException, FileNotFoundException  {    Glat parser;    p = new GlatProgram();    if (args.length > 0)    {      FileInputStream is = new FileInputStream(new File(args [0]));      parser = new Glat(new BufferedInputStream(is));    }    else    {      parser = new Glat(System.in);    }    parser.Input();    System.out.println("End Parser\n\n\n");    return p;  }  public static Variable getVariable(Token t)  {    Variable v = currMethod.getVariable(t.image);    if (v == null)    {      v = p.getGlobalVariable(t.image);      if (v == null) throw new Error("Variable: " + t.image + "does not exists on this scope");    }    return v;  }}PARSER_END(Glat)SKIP :{  " "| "\t"| "\n"| "\r"}/* COMMENTS */< AFTER_EGEN >SKIP :{  < ~[ ] > : DEFAULT}SKIP :{  < "//" (~[ "\r", "\n" ])* >| < "/*" > : ML_COMMENT_STATE}< ML_COMMENT_STATE >SKIP :{  < "*/" > : DEFAULT| < ~[ ] >}TOKEN :{  < LPAR : "(" >| < RPAR : ")" >| < LBRA : "{" >| < RBRA : "}" >| < DOTC : ";" >| < COMA : "," >}TOKEN :{ /* Operators */  < OPR : "$op" >| < ASSIG : ":=" >| < SUM : "+" >| < MIN : "-" >| < DIV : "/" >| < AST : "*" >| < LT : "<" >| < GT : ">" >| < LTE : "<=" >| < GTE : ">=" >| < EQ : "==" >| < NEQ : "!=" >}TOKEN : /* Key Words */{  < VAR : "var" >| < GLOBAL : "global" >| < INIT : "init" >  /*| < MAIN   : "main"   >*/| < START : "start" >| < TRAN : "trans" >| < TO : "->" >| < ASSU : "assume" >| < ASSE : "assert" >| < THRE : "async" >| < JOIN : "join" >| < VOID : "void" >| < LOCK : "lock" >| < UNLOCK : "unlock" >| < RETU : "return" >| < CALL : "sync" >//| < TRUE : "true" >//| < FALSE : "false" >| < NONDE : "?" >}TOKEN : /* IDs */{  < ID : < LETTER > (< PART_LETTER >)* >| < #LETTER : [ "A"-"Z", "_", "a"-"z" ] >| < #PART_LETTER :    (      < LETTER >    | [ "0"-"9" ]    ) >}/* LITERALS */< DEFAULT >TOKEN :{  < INTEGER_LITERAL :    < DECIMAL_LITERAL > ([ "l", "L" ])?  | < HEX_LITERAL > ([ "l", "L" ])?  | < OCTAL_LITERAL > ([ "l", "L" ])? >| < #DECIMAL_LITERAL : [ "1"-"9" ] ([ "0"-"9" ])* >| < #HEX_LITERAL : "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F" ])+ >| < #OCTAL_LITERAL : "0" ([ "0"-"7" ])* >| < FLOAT_LITERAL :    < DECIMAL_FLOATING_POINT_LITERAL >  | < HEXADECIMAL_FLOATING_POINT_LITERAL >>| < #DECIMAL_FLOATING_POINT_LITERAL :    ([ "0"-"9" ])+ "." ([ "0"-"9" ])* (< DECIMAL_EXPONENT >)? ([ "f", "F", "d", "D" ])?  | "." ([ "0"-"9" ])+ (< DECIMAL_EXPONENT >)? ([ "f", "F", "d", "D" ])?  | ([ "0"-"9" ])+ < DECIMAL_EXPONENT > ([ "f", "F", "d", "D" ])?  | ([ "0"-"9" ])+ (< DECIMAL_EXPONENT >)? [ "f", "F", "d", "D" ] >| < #DECIMAL_EXPONENT : [ "e", "E" ] ([ "+", "-" ])? ([ "0"-"9" ])+ >| < #HEXADECIMAL_FLOATING_POINT_LITERAL :    "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F" ])+ (".")? < HEXADECIMAL_EXPONENT > ([ "f", "F", "d", "D" ])?  | "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F" ])* "." ([ "0"-"9", "a"-"f", "A"-"F" ])+ < HEXADECIMAL_EXPONENT > ([ "f", "F", "d", "D" ])? >| < #HEXADECIMAL_EXPONENT : [ "p", "P" ] ([ "+", "-" ])? ([ "0"-"9" ])+ >| < #CHAR1 :    (      ~[ "\"", "\\", "\n", "\r" ]    | "\\"      (        [ "n", "t", "b", "r", "f", "\\", "\'", "\"" ]      | [ "0"-"7" ] ([ "0"-"7" ])?      | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]      )    ) >| < #CHAR2 :    (      ~[ "\'", "\\", "\n", "\r" ]    | "\\"      (        [ "n", "t", "b", "r", "f", "\\", "\'", "\"" ]      | [ "0"-"7" ] ([ "0"-"7" ])?      | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]      )    ) >| < STRING_LITERAL :    (      "\"" (< CHAR1 >)* "\""    | "\'" (< CHAR2 >)* "\'"    ) >}/* Program */void Input() :{  Variable v;  GlatInstruction i;  ThreadLaunch th_l;  GlatMethod m;  MainMethod main = new MainMethod();}{  < GLOBAL > < LBRA >  (    v = Decl() < DOTC >    {      p.addVar(v);    }  )*  < RBRA > < INIT > < LBRA >  (    i = InitDecl()    {      p.addInitInstr(i);    }  )*  < RBRA >  /*  < MAIN > < LBRA >	  (	    dl = Decl("main") < DOTC >	    {	      main.addDeclaration(dl);	    }	  )*	  (	    < LBRA >		  (		    	i = InitDecl()		    {		     	main.addInitInstr(i); 		    }		  ) *	  < RBRA >	)?	  (	    th_l = Threads() < DOTC >	    {	     main.addThread(th_l); 	    }	  ) *  < RBRA >*/  (    m = Func()    {      p.addMethod(m);    }  )*  < EOF >  {    //p.addMainMethod(main);    p.checkProgram();  }}//-------------------------------------------------/* ThreadsThreadLaunch Threads() :{  Token t,t2= null;  String s;  GlatInstruction cl;  Value nu=null;}{	< THRE > t = < ID >	(	  t2 = < INTEGER_LITERAL >	  | t2 = < NONDE >	) cl = Call()	{	  	if(t2 == null)			return new ThreadLaunch(t.image,t2.image,(Call)cl);		else			return new ThreadLaunch(t.image,(Call)cl);	}}*///-------------------------------------------------/* Variables */Variable Decl() :{  String s;  Token t;}{  < VAR > s = V_type() t = < ID >  {    return new Variable(s, t);  }}GlatInstruction InitDecl() :{  GlatInstruction i;}{  (    i = Assume()  | i = Assig()  )  {    return i;  }}/* Methods */GlatMethod Func() : //DONE: :D{  GlatMethod m;  GlatCFG cfg;  String s;  Token t;  Variable v;  String label;}{  s = Type() t = < ID >  {    m = new GlatMethod(s, t.image);    currMethod = m;    label = m.getLabel();  }  < LPAR >  (    v = Decl()    {      m.addParameter(v);    }    (      < COMA > v = Decl()      {        m.addParameter(v);      }    )*  )?  < RPAR > < LBRA >  (    v = Decl() < DOTC >    {      m.addVar(v);    }  )*  cfg = Cfg(m) < RBRA >  {    m.addCFG(cfg);    return m;  }}/* CFG */GlatCFG Cfg(GlatMethod m) : //DONE: :D{  Token t;  GlatTransition tr;  GlatCFG cfg;  int j = 0;}{  < START > t = < ID >  {    cfg = new GlatCFG(t.image);  }  < DOTC >  (    tr = Tran(cfg, m, j++)    {      cfg.addTransition(tr);    }  )+  {    return cfg;  }}GlatTransition Tran(GlatCFG cfg, GlatMethod m, int j) : // DONE: :D{  GlatTransition tr;  Token t1, t2;  GlatInstruction i;  GlatNode n1, n2;}{  < TRAN > t1 = < ID > < TO > t2 = < ID >  {    n1 = (GlatNode) cfg.getNode(t1.image);    n2 = (GlatNode) cfg.getNode(t2.image);    tr = new GlatTransition(m, j, n1, n2);  }  < LBRA >  (    i = Inst(m, tr)    {      tr.addInstruction(i);    }  )*  < RBRA >  {    return tr;  }}GlatInstruction Inst(GlatMethod m, GlatTransition tr) :{  GlatInstruction i;  Token t;}{  (    i = Assig()  | i = Lock()  | i = Return()  | i = Join()  | i = Call()  | i = Assume()  | i = Assert()  )  t = < DOTC >  {    i.setUbication(m, tr);    i.setPosition(t.beginLine, t.beginColumn);    return i;  }}GlatInstruction Call() :{  Token t, n;  Call c;  Variable v;  String s;}{  (    t = < THRE >  | t = < CALL >  )  {    s = t.image;  }  n = < ID >  {    c = new Call(n.image, s);  }  < LPAR >  (    v = Var()    {      c.addParameter(v);    }    (      < COMA > v = Var()      {        c.addParameter(v);      }    )*  )?  < RPAR >  {    return c;  }}GlatInstruction Lock() :{  Token t;  Variable v;}{  (    t = < LOCK >  | t = < UNLOCK >  )  v = Var()  {    return new Lock(t.image, v);  }}GlatInstruction Return() :{  Terminal t;}{  < RETU >  (    t = Term()    {      return new Return(t);    }  )?  {    return new Return();  }}GlatInstruction Join() :{  Variable v;}{  < JOIN > v = Var()  {    return new Join(v);  }}GlatInstruction Assert() : // DONE: :D{  String o;  Terminal t1, t2;  Expression e;}{  < ASSE > < LPAR > e = ExprBool() < RPAR >  {    return new Assert(e);  }}GlatInstruction Assume() : // DONE: :D{  String o;  Terminal t1, t2;  Expression e;}{  < ASSU > < LPAR > e = ExprBool() < RPAR >  {    return new Assume(e);  }}GlatInstruction Assig() :{  Variable v;  Expression exp;  GlatInstruction i;}{  v = Var() < ASSIG >  (    exp = Expr()    {      return new Assignment(v, exp);    }  | i = Call()    {      ((Call) i).setReturn(v);      return i;    }  )}Expression Expr() :{  String o = null;  Terminal t1, t2 = null;  GlatInstruction i;  Token t;  CompoundExpr e;  Expression exp;}{  (    t1 = Term()    (      o = Op() t2 = Term()      {      e = new CompoundExpr();      e.addOperandLeft( t1);      e.setOperator(o);      e.addOperandRight(t2);      return (Expression) e;   		}    )?                {        return (Expression) t1;      }    /*  | exp = PrefixExpr(){    return exp;  }*/| < MIN > t2 = Term(){	e = new CompoundExpr();      e.addOperandLeft(new IntNumber("0"));      e.setOperator(o);      e.addOperandRight(t2);}  )  }Expression ExprBool() :{  Terminal t1, t2;  String o = null;  CompoundExpr e;  Expression exp;  Token t;}{  //(     t1 = Term()    (      o = Op() t2 = Term()      {      e = new CompoundExpr();      e.addOperandLeft( t1);      e.setOperator(o);      e.addOperandRight(t2);      return (Expression) e;   		}    )?                {        return (Expression) t1;      } /* | exp = PrefixExpr()    {      return exp;    }  )*/}/*Expression PrefixExpr() :{  CompoundExpr e = new CompoundExpr();  Expression operand;  Terminal ter;  Token op;}{  < OPR > < LPAR > op = < STRING_LITERAL > // Operator  {    e.setOperator(op.image);  }  (    < COMA > operand = Expr()    {      e.addOperand(operand);    }  )+  < RPAR >  {    return (Expression) e;  }}*//*	Terminal Tokens...*/Terminal Term() :{  Token t;  Terminal ter;}{  (    ter = Var()    {      return ter;    }  | ter = Value()    {      return ter;    }  | t = < NONDE >    {      return new NonDeterministicValue(t);    }  )}Variable Var() :{  Token t;  Variable v;}{  t = < ID >  {    return getVariable(t);  }}String Op_c() : // DONE: :D{  Token t;}{  (    t = < LT >  | t = < GT >  | t = < LTE >  | t = < GTE >  | t = < EQ >  | t = < NEQ >  )  {    return t.image;  }}String Op() : // DONE: :D{  Token t;  String s;}{  (    (      t = < SUM >    | t = < MIN >    | t = < DIV >    | t = < AST >    )    {      return t.image;    }  | s = Op_c()    {      return s;    }  )}Value Value() : // DONE: :D{  Token t;}{  (    t = < INTEGER_LITERAL >    {      return new IntNumber(t.image);    }  | t = < FLOAT_LITERAL >    {      return new FloatNumber(t.image);    }/*  | t = < STRING_LITERAL >    {      return new StringValue(t.image);    }  |    (      t = < TRUE >    | t = < FALSE >    )    {      return new BoolValue(t.image);    }*/  )}String Type() : // DONE: :D{  Token t;  String s;}{  (    t = < VOID >    {      return t.image;    }  | s = V_type()    {      return s;    }  )}String V_type() : // DONE: :D{  Token t;  String s;}{  (    t = < LOCK >    {      return t.image;    }  | t = < THRE >    {      return t.image;    }  | s = P_type()    {      return s;    }  )}String P_type() : // DONE: :D{  Token t;}{  t = < ID >  {    return t.image;  }}